# 헤드퍼스트 디자인패턴 학습 저장소

이 저장소는 "헤드퍼스트 디자인패턴" 책을 기반으로 다양한 디자인 패턴들을 학습하고 구현한 코드를 모아놓은 곳입니다.

## 구성

이 저장소는 다음과 같은 패턴별 구현을 포함하고 있습니다:

### 1. 전략 패턴 (Strategy Pattern)

`/good` 디렉토리에서 Duck 예제를 통해 전략 패턴을 구현했습니다.

- **패키지 구조**:
  - `good.behavior.fly`: 날기 행동 관련 클래스
  - `good.behavior.quack`: 꽥꽥거리기 행동 관련 클래스
  - `good.model`: 오리 모델 클래스
  - `good.client`: 테스트 클라이언트 코드

- **주요 개념**:
  - 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있게 함
  - 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘이 변경될 수 있음
  - 상속 대신 구성(composition)을 활용

### 2. 옵저버 패턴 (Observer Pattern)

*(구현 예정)*

- **주요 개념**:
  - 객체 사이에 일대다 의존성을 정의
  - 주제(Subject)의 상태가 변경되면 모든 옵저버들에게 통지됨
  - 느슨한 결합(Loose Coupling)을 구현

### 3. 데코레이터 패턴 (Decorator Pattern)

*(구현 예정)*

- **주요 개념**:
  - 객체에 동적으로 책임을 추가
  - 상속을 통한 확장보다 유연한 방법 제공
  - 구성과 위임을 통해 기능을 확장

### 4. 팩토리 패턴 (Factory Pattern)

*(구현 예정)*

- **주요 개념**:
  - 객체 생성을 서브클래스에게 위임
  - 객체 생성 로직을 캡슐화
  - 클라이언트 코드와 구체적인 클래스의 인스턴스화를 분리

### 5. 싱글턴 패턴 (Singleton Pattern)

*(구현 예정)*

- **주요 개념**:
  - 클래스의 인스턴스가 하나만 생성되도록 보장
  - 전역적인 접근점 제공
  - 리소스 공유 관리에 유용

### 6. 커맨드 패턴 (Command Pattern)

*(구현 예정)*

- **주요 개념**:
  - 요청을 객체로 캡슐화
  - 매개변수화된 클라이언트를 생성
  - 요청 대기 및 로깅, 취소 가능한 연산을 지원

## 사용 방법

1. 각 패턴별 디렉토리로 이동
2. 해당 패턴의 `client` 패키지에 있는 테스트 클래스 실행

예시:
```bash or zsh
# 전략 패턴 테스트 실행
javac good/client/DuckTest.java
java good.client.DuckTest
```

## 학습 목표

- 객체지향 설계 원칙 이해 및 적용
- 디자인 패턴의 의도와 구조 파악
- 적절한 상황에서 패턴을 선택하고 적용하는 능력 개발
- 코드의 재사용성, 유연성, 확장성 향상

## 객체지향 설계 원칙

1. **캡슐화**: 변경 가능성이 높은 부분을 캡슐화
2. **상속보다는 구성**: 상속보다 구성을 활용하여 유연성 확보
3. **인터페이스에 맞춰 프로그래밍**: 구현이 아닌 인터페이스에 의존
4. **느슨한 결합**: 객체 간의 상호작용은 있되 서로에 대해 잘 모르도록 설계
5. **개방-폐쇄 원칙**: 확장에는 열려 있고, 변경에는 닫혀 있어야 함
6. **단일 책임 원칙**: 클래스는 하나의 책임만 가져야 함

## 참고 자료

- "헤드퍼스트 디자인패턴", 에릭 프리먼, 엘리자베스 롭슨 저
- [디자인 패턴 카탈로그](https://refactoring.guru/design-patterns)
- [GoF의 디자인 패턴](https://www.gofpatterns.com/)

## 기여 방법

1. 새로운 패턴 구현을 위한 브랜치 생성
2. 코드 구현 및 테스트
3. 풀 리퀘스트 생성

---

*이 저장소는 디자인 패턴 학습 목적으로 만들어졌으며, 계속해서 업데이트될 예정입니다.*
